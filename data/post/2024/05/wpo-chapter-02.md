---
title: '[웹 성능 최적화 기법] Chapter 02'
summary: 웹 최적화
date: '2024-05-30'
draft: true
tags: ['book', 'web', 'optimization']
images: []
---

# 1. 웹 최적화란

## 프론트엔드 최적화

- 웹 UI/UX와 관련된 최적화
- html, css, 이미지 파일, 외부 파일 등
- 프론트엔드 최적화를 잘 하면 브라우저의 콘텐츠 다운로드, 로딩, 렌더링할 때 속도가 빨라짐
- 특히 웹 성능은 프론트엔드 영역의 영향을 많이 받음

### 프론트엔드 최적화 대표 기술

- 스크립트를 병합(merge)하여 브라우저의 호출 개수를 줄임
- 스크립트 크기를 최소화해 바이트(byte) 자체를 줄임
- 스크립트를 **gzip** 등으로 압축하여 전달
- **webp** 등으로 브라우저 이미지 포맷을 최적화
- 이미지 손실, 무손실 압축
- **cache-control** 응답 헤더를 통해 브라우저 캐시 활용
- 도메인 수를 줄여 **DNS 조회 최소화**
- DNS 정보 미리 읽어 오기
- css를 html 상단에, javascript를 html 하단에 위치시키기
- 페이지 미리 읽어 오기 (page prefetching)
- 타사 스큷트가 웹 성능을 방해하지 않도록 조정

<aside>
💡 **gzip**
GNU zip의 줄임말로, 파일 압축에 사용되는 응용 소프트웨어
zip과 동일한 알고리즘을 사용하나, 여러 파일을 하나로 압축하는 옵션이 없다는 점에서 차이가 있음
서로 다른 파일끼리의 중복되는 부분을 압축시키기 때문에 zip에 비해 더 용량이 작음

</aside>

## 백엔드 최적화

- 웹 서버, 웹 애플리케이션 서버, 데이터베이스, 로드 밸런싱, DNS 서버 등의 시스템 관리

### 백엔드 최적화 대표 기술

- **DNS** 응답이 빨라지도록 서버 증설
- DNS 응답을 빠르게 할 수 있도록 DNS 정보 캐싱
- 웹 서버가 있는 데이터 센터의 **네트워크 출력(throughput)**, **대역폭(bandwidth)** 증설
- 웹 서버, 웹 애플리케이션 서버의 CPU, RAM 증설
- **프록시 서버**를 설정하여 웹 콘텐츠 캐싱
- **CDN**을 사용해 인터넷상에 콘텐츠 캐싱
- **데이터베이스 정규화**로 **디스크 I/O** 최적화
- **데이터베이스 캐싱**으로 빠른 응답
- **로드 밸런싱**을 통해 가장 성능이 좋은 웹 서버로 요청 연결
- 웹 애플리케이션 로직을 가볍고 빠르게 전달

## 프로토콜 최적화

- 웹 컨텐츠를 빠르게 요청하고 응답할 수 있도록

# 2. TCP/IP 프로토콜

- 웹에서는 TCP/IP 프로토콜의 일종인 **HTTP** 사용
- TCP 네트워크에서 대표적인 성능 지표는 **대역폭**과 **지연 시간**
  - 대역폭: 특정 시간 동안 얼마나 많은 네트워크 트래픽을 보낼 수 있는지 시간당 전송량
  - 지연 시간
    - 클라이언트와 서버 간 콘텐츠를 전달하는 물리적인 시간
    - 일반적으로는 클라이언트와 서버 사이 요청, 전달, 응답까지 걸리는 시간
    - 브라우저게 콘텐츠를 해석하고 화면에 렌더링하는 단계는 지연 시간에 포함하지 않음
    - 서버와 클라이언트 두 호스트를 모두 왕복하는 데 걸리는 지연 시간을 **Round Trip Time(RTT)**라고 부름

## TCP 혼잡 제어

- TCP 네트워크의 통신량을 조절하여 TCP 네트워크가 혼잡해지지 않도록 하는 방식
- 패킷을 보내는 쪽에서 네트워크에서 수용할 수 있는 양을 파악하고 그만큼의 패킷만 보내는 약속으로 TCP 혼잡을 해결

### 혼잡 제어 대표 기술

1. **느린 시작 (slow start)**
   - TCP 연결이 시작되면 전송 가능한 버퍼의 양인 혼잡 윈도우(Congestion Window, CWND)의 초깃값을 작게 설정하여 전송
   - 처음에 패킷 1개 전달 → ACK 패킷 수신 후 2개 패킷 전달 → 패킷 정상적으로 도착하면 그 2배인 4개 패킷 전달 → 패킷 유실이 발생하기 전까지 반복
2. **빠른 재전송 (fast trasmit)**
   - 먼저 도착해야 하는 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 수신자가 일단 ACK 패킷을 보내는 방식
   - 중간에 패킷 하나가 손실되면 송신자는 중복된 ACK 패킷을 통해 이를 감지하고 정상적으로 전송되지 않은 패킷 재전송
   - 중복된 패킷을 3개 받으면 반드시 손실된 패킷 재전송 및 혼잡 윈도우 창크기 감소 작업 진행
3. **흐름 제어 (flow control)**
   - TCP 송신자가 데이터를 너무 빠르게 혹은 너무 많이 전송하여 수신자의 버퍼가 오버플로되는 현상을 방지하는 기술
   - 수신자가 가지고 있는 수신 버퍼로 인해 상위 계층으로 세그먼트를 보내는 애플리케이션 프로세스에서 데이터를 읽는 속도가 느려질 수 있음
   - 송신자가 데이터를 전송하는 속도를 애플리케이션 프로세스를 읽는 속도와 유사한 수준으로 만들어 트래픽 수신 속도와 송신 속도를 일치시키는 기술

# 3. HTTP 프로토콜

## HTTP 최적화 기술

- HTTP/1.1부터 TCP/IP 연결을 재사용하는 기능 추가
  - 연결 재사용 (persistent connection)
  - 파이프라이닝 (pipelining)

## HTTP 지속적 연결

- HTTP 초기에는 3 way handshake를 통해 TCP를 연결함
  - 안전한 통신 추구
- 컨텐츠가 다양해지면서 매번 연결을 맺는 일이 성능에 영향을 주면서 지속적 연결의 필요성 대두
- HTTP 지속적 연결은 클라이언트와 서버가 TCP상에서 한 번 연결되면 완전히 끊어지기 전까지는 맺어진 연결을 지속적으로 재사용하는 기술
- HTTP 요청 헤더 중 `Connection` 헤더 이용
  - HTTP/1.1부터는 Connection 헤더를 설정하지 않아도 기본적으로 지속적 연결 지원

```jsx
// 지속적 연결 요청
Connection: keep - alive

// 지속적 연결 종료
Connection: close
```

## HTTP 파이프라이닝

- HTTP 선입 선출(FIFO, First In First Out) 방식의 단점을 극복하기 위해 개발 시작
- 먼저 보낸 요청의 응답이 없어도 다음 요청을 병렬적으로 전송하는 기술

# 4. DNS

- 인터넷 호스트명을 클라이언트와 서버가 이해할 수 있는 IP 주소로 변환해주는 시스템
- DNS 조회 속도가 느리면 웹 사이트 로딩에 영향을 줄 수 있음

## DNS 작동 원리

- 하나의 DNS 서버가 아닌 도메인 계층 구조에 따라 각각의 DNS 서버들이 관여

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/13e165f9-1e12-471d-bcc5-130f4119f051/0a17717f-da17-4dbd-8dbd-7262fb533041/Untitled.png)

1. 로컬 DNS 서버로 질의
   1. 로컬 DNS: 사용자와 인접한 DNS
   2. 이전에 동일한 도메인이 질의된 적이 있어 캐시가 남아 있다면 로컬 DNS에 캐싱하고 있는 IP 주소 반환
2. 로컬 DNS → 루트 DNS 서버로 질의
   1. 루트 DNS: 전체 도메인을 관장하는 DNS
   2. [www.example.com](http://www.example.com) 도메인에 대해 질의한다면 루트 DNS는 가지고 있는 .com 도메인 서버의 IP 정보 제공
3. 로컬 DNS → .com DNS 서버로 질의
   1. .com DNS는 자신이 알고 있는 [example.com](http://example.com) 네임 서버의 IP 정보 제공
4. 로컬 DNS → [example.com](http://example.com) DNS 서버로 질의
   1. 자신이 알고 있는 [www.example.com](http://www.example.com) 네임 서버의 IP 정보 제공

## 사용 중인 다양한 도메인 확인 방법

- 개발자 도구 → Source 탭

## 웹 성능을 최적화하는 도메인 운용 방법
